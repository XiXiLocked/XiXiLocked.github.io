---
  layout: minimal
  title: 《测试驱动开发》读后感
  comment: true
---
<p>
基本来自<a href="http://book.douban.com/subject/1230036/">kent beck的这本书</a>。</p>
<p>书中介绍了一种先写测试再写生产代码的开发流程，简称TDD(test driven development)，并且演示了2个实例用TDD的过程。题外话，我觉得就算不是来看tdd的，这本书也值得，因为大多书的书只会给你看代码成品，不会给你看中间产物（重构的书不知道是不是会展现和这本书一样细的中间产物），而这本书的2个例子有足够的慢的步伐，展示了开发的过程，其实这在书的开头也提到了，TDD的功能之一就是锻炼你以足够小的步伐开发的能力，即使你现在用不到，以后在需要的时候你会感谢你有这样的能力。</p>
<p>测试驱动开发需要有3件东西，一张任务清单，一份测试代码，一份工作代码。任务清单随时可以添加，描述你要有的功能；测试代码则是对提到的功能进行测试，进行断言，确定你的功能是完成的；工作代码的职责是显然的。从这里可以明显看出TDD的一个弱点：有2份代码需要维护，而从实践中可以发现两者的量是相当的，且一天能写的代码量大致是恒定的，所以我们关心的工作代码量会是之前的1/2。</p>
<p>整个工作流程是这样的：首先清单上写下需要完成的功能，这份清单可以动态的增加。然后，开始开发，
<ol><li>写下测试，这里用的是你理想的工作代码提供的接口来写</li>
<li>测试，注意此时因为还没有工作代码，测试一定是通不过的，甚至不能编译</li>
<li>对正式代码做一些改动，此时的主要职责是尽量快地通过编译及测试，书中提出了好几个通过测试的方法，可以从别处复制粘贴代码，可以hardcode进能过测试的值，可以写伪实现，当然也可以写明显的正确实现。</li>
<li>通过所有测试</li>
<li>重构，此时要去除重复，有的是工作代码里的重复，有的是测试代码和工作代码之间的重复（你可能hardcode了测试的数据），并优化设计结构</li>
</ol>
</p>
<p>书中提出了好几种测试：
<ul><li>为了测试功能的测试</li>
<li>把一种感觉转化为测试，比如对副作用的厌恶</li>
<li>原计划的测试太大，从而先搁置原来的测试，新写一个步伐更小的测试</li>
<li>回归测试 regression test：把一种担忧转化成一个测试，比如在某个改动之后，觉得测试肯定不过，因为xxx的原因（一个错误），但是测试却过了，这时可以添加一个检测xxx的测试，来使测试不过。</li>
<li>学习测试 learning test：测试选用语言功能的测试</li>
<li>说明测试 explanation test：为了说明一些问题，可以写一个测试，相当于一个文档</li>
</ul>
说到这里我想到unittest 和TDD其实是不同的概念，虽然他们常常混在一起。因为TDD常常写的是单元测试，而写单元测试的一般也是用TDD的。但是unittest一般是以类为单位的，但TDD不一定要写那种粒度的测试，而且unittest有时会一味强调测试的覆盖率。
</p>
<p>测试的一大作用是保证功能不被改变，至少有测试覆盖的部分。这给代码上了一层保险，方便重构，最近很迷重构呀。</p>
<p>这里再把测试先行，这样就可以有个短期目标，只要这个目标足够小，那么只需做小改动就能通过测试，这些在心理上是个很大的优势。捎带一提，刚开始一个项目，第一个测试（启动测试 starter test）可以写一些实际上没做什么工作的测试，因为代码还没长大，实际也做不了什么事，如果用一个需要做很多事情的才能实现的功能，那么TDD就不能有足够快的反馈，而且会有长时间代码不能运行，这会带来一些心理劣势。</p>
<p>TDD开发的测试覆盖率一般都很高，书上的例子覆盖率有90%多。这虽然不能作为测试质量的唯一考核，但是也是重要的指标。书中提到了一个测试质量的说法，就是抽掉一句工作代码，那么测试就不通过。</p>
<p>说一下我的感受吧，TDD首先引入了测试也做为开发的一部分，我觉得测试的一大功能是当草稿。平时开发或者debug的时候，我们也会做很多次的尝试，重新编译看效果，然后把大部分只为了做实验的代码删掉，清理现场。何不把这些测试另外放在一个地方呢？需要的时候可以随时跑一下，看看效果，至少是我，经常反复地改代码，实验版本a,b,c之前切换来切换去。把这些版本全部留下来可以节省很多时间。</p>
<p>然后是TDD快速的开发节奏。我在实验书上的例子的时候，至多隔1分钟就会跑一遍测试，然后逐渐把改动的步子减小，变成改一行就跑测试的节奏，因为很快就得到反馈，也可以从反馈中得到自信，反过来不运行测试就会心慌。这是TDD的一大特点，测试快，测试快就需要代码结构好，代码足够高内聚低耦合，可以动用尽可能少的代码就写完一个测试，尽可能少不止包括测试里的代码少，还有牵涉到工作代码的部分也少。</p>
<p>小步伐。虽然说可以以不同步伐开发，在实际中调节，但是TDD用的越多会更倾向于小步伐地开发。</p>
<p>也想到了什么应该写什么样的测试，这里不是说什么种类的测试，而是对测试的要求，有人总结是FIRST: Fast, Independent, Repeatable, Self-validating, Timely. </p>
<p>一些写测试的建议<br />
我们应该从哪儿开始构建一个系统？从我们对最终系统的描述开始。<br />
我们应该从哪儿开始编写一项功能？从我们希望最终代码能够通过的测试开始。<br />
我们应该从哪儿开始写一个测试？从测试完成是能够通过的断言开始。</p>
<p>题外话，一个是比喻，在第一个例子里，用expression来作为资金转换的比喻，给实现代码带来了很大的方便，所以比喻是很重要的。一个是错误，当我们发现断言正确时，一切都很美好，但是当断言失败时，我们发信debug的时间会有长有短，但是大致上是长的，所以最好在错误的地方提供足够的错误信息。一个是期望异常，测试抛出希望的异常，可以这样：try catch住期望的异常，然后在抛异常的下一行放fail()报告没有抛出期望的异常。</p>
